"""
Copyright 2012 Gregory Finley

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

# FLEx-TeX
# for configured FLEx dictionary with sorting and Tcl/Tk GUI
# Greg Finley, 2012-2013

import sys, os, shutil
import xml.etree.ElementTree as ET
import datetime
import string
import Tkinter
import tkFileDialog

makedic = False

class Application(Tkinter.Frame):

    def createWidgets(self):
        self.msg = Tkinter.Message(self)
        self.msg["text"] = """
Click the button below to start FLEx-TeX.

You will be asked to locate four files:

1    XML file from FLEx - the content of your dictionary.

2    Alphabet file - contains a custom alphabet and letter headings.
    (If skipped, will use English alphabetization rules with capital letter headings.)

3    Custom command definitions - if you've already specified the formatting commands in \
LaTeX from a previous build, select that file here.
    (If skipped, will use the generated file with blank field definitions.)

4    LaTeX main file - contains headers, formatting, and the necessary "\\input{}" statements.


See the included documentation and examples/defaults for more details.
        """
        self.msg.pack()

        self.sort = Tkinter.Checkbutton(self)
        self.sortbox = Tkinter.IntVar()
        self.sort["variable"] = self.sortbox
        self.sort["text"] = "Sort entries alphabetically?"
        self.sort.select()
        self.sort.pack()

        self.go = Tkinter.Button(self)
        self.go["text"] = "Locate files"
        self.go["command"] = self.letsgo
        self.go.pack()

    def letsgo(self):
        self.makedic=True
        self.quit()

    def __init__(self, master=None):
        Tkinter.Frame.__init__(self, master)
        self.pack()
        self.master.title("FLEx-TeX")
        self.createWidgets()
        self.makedic = False

app = Application()
app.mainloop()
if not app.makedic: os._exit(0)

xmlfilemsg = "XML file from FLEx?"
xmlfile = tkFileDialog.askopenfilename(title = xmlfilemsg)

if not xmlfile: os._exit(0)

alphafilemsg = "Alphabet file? Hit 'Cancel' to use English alphabetization."
alphafile = tkFileDialog.askopenfilename(title = alphafilemsg)

defsfilemsg = "Custom command definitions? Hit 'Cancel' to use the file generated by FLEx-TeX."
defsfileusr = tkFileDialog.askopenfilename(title = defsfilemsg)

mainfilemsg = "LaTeX main file? Hit 'Cancel' to supply the file manually later."
mainfile = tkFileDialog.askopenfilename(title = mainfilemsg)

app.master.destroy()


# Once the applet closes, make the dictionary

now = datetime.datetime.now()

# ~~~~~~~~~
# Functions
# ~~~~~~~~~

# Here is the key function (works with Python 3)
def gregSortKey(word, alphabet):
    i = 0
    score = ""

    while i < len(word) :
        # check for digraphs (or trigraphs)
        char = getMaximalLetter(word[i:], alphabet)
        # And if we did use a long letter, be sure to update our counter

        if not char in alphabet : char = word[i]

        i += len(char) - 1

        if not char in alphabet: char = 'default'

        score += chr(alphabet[char])
        score += ""
        i += 1
# And return the final score
    return score


# Finds the maximal letter in a string, beginning at a specified index.
# Good for digraphs, trigraphs, or larger (e.g., combining characters!)

def getMaximalLetter(word, alphabet) :
    substr = ''
    n = 0
    letter = word[n]
    while n < len(word) :
        substr += word[n]
        if substr in alphabet :
            letter = substr
            i = n
        n += 1
    return letter

# To strip out pesky \n and \r characters

def fixline(line) :
    line = line.replace("\r",'')
    line = line.replace("\n",'')
    return line

def fixtag(tag) :
    tag = tag.replace("_","")      # LaTeX doesn't like these characters
    tag = tag.replace("-","")
    tag = tag.replace(".","")
    tag = tag.replace("*","")
    # And this will replace numbers with letters
    for digit in string.digits:
        tag = tag.replace(digit,string.ascii_uppercase[int(digit)])
    return tag

# In case there are cross-references

def subscript_final_numbers(txt):
    numerals = []
    for a in range(10): numerals.append(str(a))

    if len(txt) < 2 or txt[0] in numerals: return txt

    if txt[-1] in numerals:
        if txt[-2] in numerals:
            txt = txt[0:-2] + "\\textsubscript{" + txt[-2:] + "}"
        else:
            txt = txt[0:-1] + "\\textsubscript{" + txt[-1:] + "}"

    return txt

# ~~~~~~~~~~~~~~
# Variable setup
# ~~~~~~~~~~~~~~

allTags = []
thispath = os.path.dirname(sys.argv[0])
defaultxml = "xmlfile.xml"
entriesfilename = "entries.tex"
defsfilename = "all_field_types.tex"
defsfilealtname = "all_field_types_blank.tex"
outfilename = "dictionary.tex"

# ~~~~~~~~~~~~~~~
# File operations
# ~~~~~~~~~~~~~~~

newpath = str(now.year) + "-" + str(now.month).zfill(2) + "-" + str(now.day).zfill(2) + "_" + str(now.hour).zfill(2) + str(now.minute).zfill(2)
newpath = os.path.join(thispath,newpath)
defaultpath = os.path.join(thispath,"default")

if not os.path.exists(newpath):
    os.makedirs(newpath)
outfile = open(os.path.join(newpath, entriesfilename),'w')
defsfile = open(os.path.join(newpath, defsfilename),'w')
try:
    shutil.copyfile(mainfile, os.path.join(newpath, os.path.split(mainfile)[-1]))
except:
    # Change this to a GUI message
    print("No main file found. You'll need to supply a LaTeX file with the \\input{} statement later.")

# Alphabet file

if alphafile:
    alphaData = open(alphafile,'r')

    i = 1
    alphabet = {'default':0}   # The alphabet itself
    headings = {}   # This dict contains what will be written for headings
    keyName = ""    # Temporary variable (see below)

    for line in alphaData:
        line = fixline(line)

        bothHalves = line.split("\t")
        try:
            keyName = bothHalves[0]
            characters = bothHalves[1]
        except:
            print("Alphabet file not configured properly.")

        for character in characters.split() :
            alphabet[character] = i
        headings[i] = keyName
        i += 1
    alphaData.close()


# Use default English alphabet if no file specified
else:
    alphabet = {'default':0}
    headings = {}
    for i in range(26):
        alphabet[string.uppercase[i]] = i
        alphabet[string.lowercase[i]] = i
        headings[i] = string.uppercase[i]


# Get the XML


try:
    tree = ET.parse(xmlfile)
except:
    # Print a little graphical message here maybe?
    print("No dictionary file found. Exiting.")
    os._exit(0)

root = tree.getroot()

# Set up the master list and counter

masterlist = []
mlcount = 0


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create list of entries using XML input
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# For FLEx 8: comb through all LexEntries and build up a dictionary of
#   IDs with headwords
# This has to be done outside the main loop to be sure they all get built

wordByID = {}
for entry in root.findall('LexEntry'):
    if 'id' in entry.attrib:
        thisid = entry.attrib['id']
    try:
        wordByID[thisid] = entry.getiterator('Run')[0].text
    except:
        pass





for entry in root.findall('LexEntry'):

    # If there are multiple senses, set it to display the numbers; otherwise, no.
    # There's probably a better way to code this but this works for now
    nsenses = 0
    for item in entry.getiterator():
        if 'number' in item.attrib:
            nsenses += 1
    if nsenses > 1 :
        multsenses = True
    else:
        multsenses = False

    # Becomes False after the first <Run> content encountered
    headword = True

    for item in entry.getiterator():

        if len(item) and len(item[0]):

            if item[0][0].tag=="Run":
                tag = item.tag
                # Add language to the tag name (for multilingual dictionaries)
                try:
                    tag += item[0][0].attrib['ws']
                except:
                    pass
                tag = fixtag(tag)

                # This loop is necessary in case we have multiple Run tags...
                #   which FLEx sometimes does.
                i = 0
                txt = ''
                while len(item[0]) > i:
                    if item[0][i].tag=="Run":
                        txt += item[0][i].text.encode('utf-8')
                    i += 1

                txt = subscript_final_numbers(txt)

                # Before writing the word, see if we're at a new entry
                # And, if so, see also if we're at a new letter

                if headword :

                    masterlist.append(['',''])
                    masterlist[mlcount][1] += '\\entry{' + txt + '}{\n'
                    masterlist[mlcount][0] = txt
                    headword = False
                    firstReference = True       # For FLEx 8 compat

                # Now write the word and its LaTeX command to the outfile

                masterlist[mlcount][1] += '\t\\' + tag + '{' + txt + '}\n'
                if tag not in allTags:
                    allTags.append(tag)

            elif item[0][0].tag=="Alt" and headword == False:
                writeThisEntry = True

                tag = fixtag(item.tag)
                noWs = item[0][0].attrib
                if 'ws' in noWs :
                    del noWs['ws']
                if 'entry' in noWs :
                    txt = noWs['entry'].encode('utf-8')
                elif 'name' in noWs:
                    txt = noWs['name'].encode('utf-8')
                elif len(noWs) :
                    txt = noWs[noWs.keys()[0]].encode('utf-8')
                else:
                    writeThisEntry = False
                if writeThisEntry :
                    txt = subscript_final_numbers(txt)
                    masterlist[mlcount][1] += '\t\\' + tag + '{' + txt + '}\n'
                    if tag not in allTags:
                        allTags.append(tag)

        if 'number' in item.attrib and multsenses and headword == False:
            masterlist[mlcount][1] += '\\' + 'Numbering{' + item.attrib['number'] + '}\n'

        # For FLEx 8
        if item.tag == 'Link' and 'target' in item.attrib:
            if firstReference:
                reftag = 'LinkedHeadword'
            else:
                reftag = 'LinkedHeadwordSubsequent'
            try:
                toWrite = wordByID[item.attrib['target']].encode('utf-8')
            except:
                print 'The reference "' + item.attrib['target'] + '" does not point to an entry in the XML file. Perhaps FLEx is excluding it from export.'
            masterlist[mlcount][1] += '\t\\' + reftag + '{' + toWrite + '}\n'
            firstReference = False



    # If headword isn't False, we haven't actually done anything!
    if headword == False:
        masterlist[mlcount][1] += '}\n\n'
        mlcount += 1

# Now sort all the entries

if app.sortbox.get() :
    if alphafile:
        masterlist.sort(key=(lambda x: gregSortKey(x[0], alphabet)))
    else:
        masterlist.sort(key=(lambda x: x[0].lower()))

# Now it's time to write the output file.

curletter = 'default';
for entry in masterlist :
    thisfirstletter = getMaximalLetter(entry[0],alphabet)#.encode('utf-8')

    if thisfirstletter in alphabet and curletter in alphabet and alphabet[thisfirstletter] != alphabet[curletter]:
        curletter = thisfirstletter
        outfile.write('\\NewLetter{' + headings[alphabet[curletter]] + '}\n')

    outfile.write(entry[1])


# Write the other file with all the LaTeX \newcommands

defsfile.write('\\newcommand{\\entry}[2]{#2}\n')
defsfile.write('\\newcommand{\\Numbering}[1]{#1}\n')
defsfile.write('\\newcommand{\\NewLetter}[1]{\\section*{#1}\\noindent\\\\}\n')
for tag in allTags :
    defsfile.write('\\newcommand{\\' + tag + '}[1]{#1}\n')
# FLEx 8
defsfile.write('\\newcommand{\\LinkedHeadword}[1]{#1}\n')
defsfile.write('\\newcommand{\\LinkedHeadwordSubsequent}[1]{#1}\n')

defsfile.close()

# Did the user pick a custom defs file? If so, let's use that one but keep our alt handy.
if defsfileusr :
    shutil.move(os.path.join(newpath, defsfilename), os.path.join(newpath, defsfilealtname))
    shutil.copyfile(os.path.join(defsfileusr), os.path.join(newpath, defsfilename))


outfile.close()
